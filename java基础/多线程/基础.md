## Thread的基本方法

| 方法名             | 描述                           |
| ------------------ | ------------------------------ |
| currentThread      | 获取当前线程                   |
| getName            | 获取线程名                     |
| isAlive            | 是否活动                       |
| getId              | 获取Id                         |
| yield              | 把线程状态从running转换为ready |
| interrupt          | 打断标识，不会真正的打断       |
| isInterrupted      | 判断是否是打断                 |
| setDaemon(boolean) | 守护线程,需要在线程启动前设置  |
| getState()         | 获取线程状态                   |
|                    |                                |
|                    |                                |

守护线程：在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出

## 线程的生命周期

​	new：创建线程对象

​	runnable：一个复合状态，是ready和running，yield()方法就是将线程的状态从running转变成ready

​	blocked：阻塞，线程发起的阻塞的I/O操作，或者申请由其他线程占用的独占资源

​	waiting：等待，线程执行objtct.wait(), thread.join()方法，线程转变成waiting。object.notify(),或者其他加入的线程执行完毕，线程转变成runnable

​	time_waiting：和wait类似，Thread.sleep(long), Object.wait(long) 进入该状态。但是他会在指定时间过后自动转变成runnable

​	terminated：终止，线程结束

## java的内存模型

![image-20220711112923231](%E5%9F%BA%E7%A1%80.assets/image-20220711112923231.png)

简单版

![image-20220711113058782](%E5%9F%BA%E7%A1%80.assets/image-20220711113058782.png)

共享数据不可见

## 锁

内部锁：通过synchronized实现(非公平锁)

显示锁：通过java.concurrent.locks.Lock接口实现(公平锁和非公平锁)

作用：实现共享数据的安全访问，保障线程的原子性，可见性，有序性

原子性：一个线程只能被一个线程持有

可见性：获取锁会刷新处理器的缓存(获取最新的数据)，释放锁会冲刷处理器的缓存(将缓存的数据更新)。

### 相关概念：

可重入性：一个线程持有该锁的时候，又继续申请该锁，能申请成功就是可重入性，不能成功就是不可重入

锁的粒度：一个锁可以保存的数据量的大小。相对的概念，如果锁的粒度太粗，线程申请锁时会进行不必要的等待（一个银行的柜头可以执行所有的业务，就太慢了）；锁的粒度太细会增加系统的开销(银行对每个业务开放柜台，对应每个柜台都要发放工资，开销大)。



## synchronized

### 同步代码块

只要是同一把锁，就可以锁住

this 锁对象

```java
Test test = new Test();
// 开启一个线程
new Thread(new Runnable(){
    @Override
    pubilc void run(){
        test.fun();
    }
}).start();
// 开启另一个线程
new Thread(new Runnable(){
    @Override
    pubilc void run(){
        test.fun();
    }
}).start();


public void fun(){
   synchronized(this){ // this,谁调用这个方法，谁就是this，因为两个线程都是test调用的，所以this是同一个，所以可以同步
       ...
   } 
}
```

常量锁对象

```java
Test test1 = new Test();
Test test2 = new Test();

// 开启一个线程
new Thread(new Runnable(){
    @Override
    pubilc void run(){
        test1.fun();
    }
}).start();
// 开启另一个线程
new Thread(new Runnable(){
    @Override
    pubilc void run(){
        test2.fun();
    }
}).start();

public static final Object OBJ = new Object();

public void fun(){
   synchronized(OBJ){ // 使用常量来做锁对象，即使是不同的对象调用，因为OBJ是不变的是一致的，所以可以同步
       ...
   } 
}
```

### 同步方法

synchronized修饰实例方法，默认锁对象是this

synchronized修饰静态方法，默认锁对象是运行时类对象（类锁），即XXX.class(某个类的字节码)

```java
public void fun(){ // 修饰实例方法
    synchronized(Test.class) {
        ...
    }
    
}
public synchronized void fun(){ // 修饰实例方法
    
}

public static synchronized void fun2(){  //修饰静态方法
    
}
```

```java
Test test = new Test();
// 开启一个线程
new Thread(new Runnable(){
    @Override
    pubilc void run(){
        test.fun();  // synchronized 修饰代码块，锁为类锁
    }
}).start();
// 开启另一个线程
new Thread(new Runnable(){
    @Override
    pubilc void run(){
        Test.fun2();  // synchronized 修饰静态方法，默认是类锁
    }
}).start();
```

一般情况下，同步代码块比同步方法的效率高

```java
public void fun(){
    ...  //耗时3秒,然后加锁
    synchronized (this) {
        
    }
}
// 开启多线程，时间基本上为3+线程数*同步代码块的时间
```

```java
public synchronized void fun(){
    ...  //耗时3秒,然后加锁
    synchronized (this) {
        
    }
}
// 开启多线程，时间基本上为(3+同步代码块) * 线程数的时间
```

同步代码块中出现异常，会自动释放锁

避免死锁：索引线程获得锁的顺序保持一致就可以了

## volatile

使变量在多个线程中可见，只是保证数据得可见性，不能保证原子性，只能修饰变量

synchronized修饰得代码块和方法，可以保证可见性和原子性



## 乐观锁

| 分组       | 原子变量类                                                   |
| ---------- | ------------------------------------------------------------ |
| 基础数据   | AtomicBoolean，AtomicInteger，AtomicLong                     |
| 数组型     | AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray    |
| 字段更新器 | AtomicIntegerFieldUpdater，AtomicLongFieldUpdater，AtomicReferenceFieldUpdater |
| 引用性     | AtomicReference，AtomicStampedReference，AtomicMarkableReference |














