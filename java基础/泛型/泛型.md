# 泛型的好处

简单易用 消除强制类型转换 保证类型安全

>对于方法泛型中得fun(); 函数，返回的值是泛型，在编译阶段会自动检查

# 方法泛型

在定义方法泛型时, 在方法返回值类型前面使用尖括弧<T>来声明，方法参数可以是泛型

```java
class Temp{
    public static void main(String[] args) {
        String asdfasdf = fun("asdfasdf");
        Integer integer = fun(12);
        Double aDouble = fun(23.15);
        // Integer integer = fun("asdfasdf"); // 编译不会通过
        fun2(213);    // 输出213
        fun2("asdfasdf"); // 输出asdfasdf
    }
    public <T> T fun(T t){
        return t;
    }
    
    public <T> void fun2(T t){
         System.out.println(t);
    }
}
```

# 类泛型

## 声明泛型类

在类名后面使用<T>声明类泛型

```java
// 在实例化中需指定T的数据类型，如果不指定，默认是Object类型
public class Demon <T> {
  //定义泛型成员变量，此处的T是外部指定的，即GenDemo<T>中的T。
  private T data;
  // 约定返回值的类型
  public T getData () {
    return this.data;
  }
  // 约定传入参数的类型
  public void setData (T data) {
    this.data = data;
  }
}
```

## 使用泛型类

```java
Demon<String> demon = new Demon<>();
demon.setData("wahaha");
String str = demon.getData();

// 未指定数据类型，默认为Object
Demon demon1 = new Demon<>();
demon1.setData("wahaha");
Object obj = demon1.getData();
```

# 接口泛型

## 定义接口泛型

```java
/**
 * 
 * 定义接口时指定了一个类型形参，该形参名为E
 * 此处的E(Element)也可以任意标识
 * @param <E>
 */
public interface Gen<E> {
 
	//该接口方法，返回E形参的实例
	E getGenInfo();
	
	//在接口方法中，E可作为类型使用
	void addGenInfo(E e);
 
}
```

## 实现接口泛型

```java
public class GenImpl implements Gen<String>{
	private String content;
	public String getGenInfo() {
		return content;
	}
	public void addGenInfo(String e) {
		this.content=e;
	}
}
```

